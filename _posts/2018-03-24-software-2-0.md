---
layout: post
title: Software 2.0
---
作者：[Andrej Karpathy](https://medium.com/@karpathy/software-2-0-a64152b37c35)
译者：[Ray](https://0.61803398875.xyz/)

> 译者注：本文作者 Andrej Karpathy 是 Tesla 公司的 AI 总监。此前在 OpenAI 担任研究科学家，斯坦福大学博士。博士在读期间，他曾在 Google 实习，学习 YouTube 视频大规模特征，并在 DeepMind 进行深度强化学习。他还与李飞飞合作研究卷积/回归神经网络架构及其在计算机视觉、自然语言处理以及两者结合领域的应用，并在斯坦福大学首开深度学习课程，视觉识别的卷积神经网络 ([CS231n](http://cs231n.stanford.edu/))。此外， Andrej 还开发了一个深度学习图书馆  [arxiv-sanity.com](http://arxiv-sanity.com/)，用户可在该网站查到近几年来关于深度学习的 43809 篇论文。

（正文）

我经常会看到人们将神经网络称为“另一个机器学习工具箱中的工具”。它们有一些优点和缺点，它们在这里或那里工作，有时你还可以用它来赢得 Kaggle 比赛。不幸的是，这种解释见树不见林（忽视了大局）。神经网络不仅仅是另一个分类器，它代表了我们编写软件的根本性转变的开始。它们是软件 2.0（Software 2.0)。

我们都熟悉软件 1.0 的“经典堆栈” - 它是用 Python，C ++ 等语言编写的。它由程序员写给计算机的明确指令组成。通过编写代码，程序员可以识别出程序中具有某些期望行为的特定点。

![图片](https://dn-coding-net-production-pp.qbox.me/a0c6e349-ad9f-46e5-adb9-cf05268f7679.jpeg)

相比之下，软件 2.0是用神经网络权重编写的。没有人参与编写这些代码，因为有很多权重（典型的网络可能有数百万），直接用权重编码很难（我试过）。相反，我们对所需程序的行为（例如一个输入输出实例对的数据集）指定了一些约束，并使用我们可用的计算资源来搜索程序空间以找到满足约束条件的程序。在神经网络的情况下，我们将搜索限制在程序空间的连续子集，在该子集中，搜索过程可以通过反向传播和随机梯度下降法而变得(令人惊讶地)有效。

事实证明，大部分现实世界的问题都具有这样的性质，即收集数据（或者更一般地说，确定理想的行为）比显示编程要容易得多。未来很大一部分程序员不会维护复杂的软件库，编写错综复杂的程序或分析其运行时间。他们收集，清理，控制，标注，分析和可视化提供给神经网络的数据。

![图片](https://dn-coding-net-production-pp.qbox.me/8aec7678-c5bd-4290-aa3a-624fa45242b6.png)

软件 2.0 不会取代软件 1.0（实际上，需要大量的软件 1.0 基础来训练和推断“编译”软件 2.0 的代码），但它将接管今天软件 1.0 负责的越来越多的部分。 让我们来看一些正在进行的过渡的例子，以使其更具体：

**视觉识别** 过去是由工程特征组成的，最后在末端加上一些机器学习的东西（如 SVM）。 从那时起，我们开发了机器来发现更强大的图像分析程序（在 ConvNet 体系结构中），最近我们已经开始 [基于架构搜索](https://arxiv.org/abs/1703.01041)。

**语音识别** 过去涉及到大量的预处理、高斯混合模型和隐马尔可夫模型，但 [现在](https://github.com/syhw/wer_are_we) 几乎全部由神经网络组成。1985 年 Fred Jelinek 给出了一个相关的，经常被引用的幽默名言是：“每次我开除一个语言学家，我们的语音识别系统的性能都会提高”。

**语音合成** 在历史上一直用各种拼接机制来实现的，但是现在最先进的模型是产生原始音频信号输出的大型 ConvNets（例如 [WaveNet](https://deepmind.com/blog/wavenet-launches-google-assistant/)）。

**机器翻译** 通常采用基于短语的统计技术，但神经网络很快成为主导。 我最喜欢的架构是在 [多语言环境](https://arxiv.org/abs/1611.04558) 中进行训练的，在这种环境下，单一模型可以从任何源语言翻译成任何目标语言，在弱监督（或 [无监督式](https://arxiv.org/abs/1710.11041)）的环境中训练。

**游戏** 围棋程序已经存在很长时间了，但是 [AlphaGo Zero](https://deepmind.com/blog/alphago-zero-learning-scratch/) (一个观察棋盘原始状态并进行移动的 ConvNet )现在已经成为这个游戏中最强大的玩家。我预计在其他领域会看到非常相似的结果，例如 [DOTA 2](https://blog.openai.com/more-on-dota-2/) 和 [星际争霸](https://deepmind.com/blog/deepmind-and-blizzard-open-starcraft-ii-ai-research-environment/)。

**机器人** 具有将传感，姿态估计，计划，控制，不确定性建模等问题分解为多个显式表示和算法的悠久传统。 我们还没有完成，但 [加州大学伯克利分校](https://www.bloomberg.com/features/2015-preschool-for-robots/) 和 Google 的研究表明，软件 2.0 可能能够更好地代表这些代码。

**数据库** 人工智能之外的更多传统系统也会看到过渡的早期迹象。 例如，“[学习索引结构的案例](https://arxiv.org/abs/1712.01208)”用神经网络取代了数据管理系统的核心组件，在速度上优于高速缓存优化的 B 树高达 70 %，同时在内存中节省了一个数量级。

您会注意到我上面的很多链接都涉及在 Google 完成的工作。 这是因为 Google 目前处于将大部分代码重写到软件 2.0 代码中的最前沿。 “[一统天下的模型](https://arxiv.org/abs/1706.05137)” 为我们提供了一个初步的示意图，这可能看起来像各领域的统计强度合并成为一个对世界一致的认知。

### 软件 2.0 的好处

我们为什么更喜欢将复杂的程序移植到软件 2.0 中？显然，一个简单的答案是他们在实践中工作得更好。但是，还有很多其他合适的理由来选择这个堆栈。让我们来看看软件 2.0（想一想：ConvNet） 的一些好处，与软件 1.0（考虑：生产级的 C ++ 代码库）相比较，软件 2.0 是：

**计算均匀** 一个典型的神经网络一阶由两个操作的层组成：矩阵乘法和零阈值( ReLU )。与传统的软件指令集相比，其异构性和复杂性明显提高。因为您只需为少数核心计算原语(例如矩阵乘法)提供软件 1.0 实现，所以更容易保证正确性/性能。

**容易烧成硅** 作为推论，由于神经网络的指令集相对较小，所以实现这些网络非常接近硅，如定制的 [ASICs](https://www.forbes.com/sites/moorinsights/2017/08/04/will-asic-chips-become-the-next-big-thing-in-ai/#7d6d7c0511d9)，[神经形态芯片](https://spectrum.ieee.org/semiconductors/design/neuromorphic-chips-are-destined-for-deep-learningor-obscurity) 等等。 当低功率智能变得无处不在时，世界将会发生改变。 例如，小型便宜的芯片可以配备预训练的 ConvNet，语音识别器和 WaveNet 语音合成网络，所有这些都集成在一个小型原型中，你可以将其连接到任何设备上。

**持续运行时间** 典型的神经网络正向传递的每次迭代都需要完全相同的 FLOPS （浮点运算时间）。基于您的代码可能通过一些庞大的 C++ 代码库的不同执行路径，不存在任何可变性。当然，你的计算图可以是动态的，但执行流通常仍然受到显著约束。这样一来我们几乎就能保证永远也不会陷入到意外的无限循环之中。

**恒定内存使用** 与上述相关的是，在任何地方都没有动态分配的内存，所以交换到磁盘或者必须在代码中搜索内存泄漏的可能性也很小。

**高度可移植** 与传统的二进制文件或脚本相比，矩阵乘法的序列在任意计算配置上运行起来要容易得多。

**它非常敏捷** 如果你有一个 C++代码，有人希望你使其速度提高一倍（如果需要的话，以性能降低为代价），那么为新规范调整系统将是非常重要的。但是，在软件 2.0 中，我们可以利用我们的网络，删除一半信道，重新训练，并且在那里 - 运行速度是其两倍，并且运行速度更糟糕。这是魔法。相反，如果您碰巧有更多数据/计算，只需添加更多通道并重新训练，您就可以立即使程序更好地工作。

**模块可以融合成一个最佳整体** 我们的软件通常被分解为通过公共功能，API 或端点通信的模块。但是，如果两个最初分别受过训练的软件 2.0 模块进行交互，我们就可以轻松地在整个系统中反向传播。想想看，如果您的网络浏览器能够自动重新设计底层系统指令 10 层以下以实现更高的网页加载效率，那将会有多惊人。有了软件 2.0，这将是默认的行为。

**易学** 我喜欢开玩笑说深度学习很浅薄。它不是需要博士学位才能做出点有用的东西来的核物理。其基本概念只需要一点基础的线性代数、微积分、Python，然后听听 CS231n 的课程即可。当然，大量的专业知识和直觉掌握起来是需要时间的，所以准确点的说法是，软件2.0 入门容易，精通很难。

**比你强** 最后，也是最重要的一点，在很大一部分的有价值的垂直领域中，至少在图像/视频，语音/语言以及文本方面，神经网络要比你我任何人能想出的代码都要好。


### 软件 2.0 的局限性

2.0 技术栈也有其自身的一些缺点。在优化结束时，我们得到的大型神经网络运行良好，但很难说清楚其缘由。在许多应用领域，我们可以选择使用我们了解的90 %精确模型，或者使用我们不了解的99 %精确模型。

2.0 技术栈可能会以 [不直观和令人尴尬的方式失败](https://motherboard.vice.com/en_us/article/nz7798/weve-already-taught-artificial-intelligence-to-be-racist-sexist)，或者更糟糕的是，他们可能会“默默地失败”，例如通过在它们的训练数据中悄悄地采用了偏差，当它们的大小在大多数情况下很容易达到数百万时，很难正确地分析和检查它们。

最后，我们还发现这个堆栈的一些特殊属性，如 [对抗例子](https://blog.openai.com/adversarial-example-research/) 和 [攻击](https://github.com/yenchenlin/awesome-adversarial-machine-learning) 的存在就聚焦了这一技术栈的不直观性。


### 最后几点想法

如果你认为神经网络是一个技术栈，而不仅仅是一个很好的分类器，很快你就会发现它在变革整个软件方面具有庞大的优势和潜力。

从长远来看，软件 2.0 的未来很光明，因为许多人越来越清楚，当我们开发 AGI 时，它肯定会用软件 2.0 编写。

至于软件 3.0？ 这完全取决于 AGI（通用人工智能）。



